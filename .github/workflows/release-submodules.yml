name: 自动发布 - 根据主标签创建子模块标签

on:
  push:
    tags:
      - "v*" # 当 v* (例如 v0.1.0) 格式的标签被推送到仓库时触发

jobs:
  release-submodules:
    runs-on: ubuntu-latest
    permissions:
      contents: write # 需要写权限才能将提交和标签推送回仓库
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          # 需要获取完整的 Git 历史和所有标签
          fetch-depth: 0
          # 显式地签出 master 分支，以避免 "detached HEAD" 状态
          # 如果您的主分支不是 'master'，请修改为正确的名称 (例如 'main')
          ref: master

      - name: 设置 Go 环境
        uses: actions/setup-go@v5
        with:
          go-version: "1.23"

      - name: 配置 Git 用户
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: 从 Git Ref 中提取标签名称
        id: get_tag
        run: echo "TAG_NAME=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV

      - name: 更新依赖并为子模块打标签
        run: |
          set -e
          VERSION=${{ env.TAG_NAME }}

          echo "由主标签触发: $VERSION"
          echo ""

          # --- 第 1 步: 根据规则更新依赖 ---
          echo "===== [1/3] 正在更新子模块依赖... ====="
          find . -name go.mod | while read -r mod_file; do
            dir=$(dirname "$mod_file")
            if [ "$dir" == "." ]; then
              continue
            fi
            
            module_path=${dir#./}
            echo "-> 正在处理模块: $module_path"
            
            ( # 使用子 shell 以避免更改当前目录
              cd "$dir"
              # 规则: 为 cmd/maltose 模块移除 replace 指令
              if [[ "$module_path" == "cmd/maltose" ]]; then
                echo "   - [CMD 规则] 正在移除 replace 指令..."
                if grep -q "github.com/graingo/maltose =>" go.mod; then
                  go mod edit -dropreplace=github.com/graingo/maltose
                fi
              # 规则: 为 contrib/* 目录下的模块保留 replace 指令
              elif [[ "$module_path" == contrib/* ]]; then
                echo "   - [CONTRIB 规则] 正在保留 replace 指令。"
                # 无需操作
              fi
              
              echo "   - 正在设置 maltose 依赖为 $VERSION..."
              go mod edit -require="github.com/graingo/maltose@$VERSION"
              echo "   - 正在整理 go.mod..."
              go mod tidy
            )
          done
          echo "=========================================="
          echo ""

          # --- 第 2 步: 提交依赖变更 ---
          echo "===== [2/3] 正在提交依赖变更... ====="
          if git diff-index --quiet HEAD --; then
              echo "-> 没有依赖变更需要提交。"
          else
              echo "-> 正在为 $VERSION 提交依赖对齐的 commit..."
              git add .
              git commit -m "chore(release): 为 $VERSION 对齐依赖"
              echo "-> 正在推送 commit..."
              git push
          fi
          echo "=========================================="
          echo ""

          # --- 第 3 步: 为尚不存在的子模块标签打标签 ---
          echo "===== [3/3] 正在创建并推送新标签... ====="
          NEW_TAGS=""
          find . -name go.mod | while read -r mod_file; do
            dir=$(dirname "$mod_file")
            # 跳过根模块，因为它已经被触发此流程的标签标记了
            if [ "$dir" == "." ]; then
              continue
            fi
            
            module_path=${dir#./}
            TAG_NAME="${module_path}/${VERSION}"
            
            if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
              echo "   - 标签 '$TAG_NAME' 已存在，跳过。"
            else
              echo "   - 正在为模块 '$module_path' 创建标签 '$TAG_NAME'"
              git tag "$TAG_NAME"
              NEW_TAGS="$NEW_TAGS $TAG_NAME"
            fi
          done

          # --- 第 4 步: 仅推送新创建的标签 ---
          if [ -z "$NEW_TAGS" ]; then
            echo "-> 没有新的子模块标签需要推送。"
          else
            echo "-> 正在推送新标签: $NEW_TAGS"
            # 移除前导空格
            NEW_TAGS=$(echo "$NEW_TAGS" | sed 's/^ *//g')
            git push origin $NEW_TAGS
          fi
          echo "=========================================="

          echo "✅ 子模块发布流程成功完成！"
