name: 手动发布
# 更新依赖并标记所有模块

on:
  # 允许从 GitHub Actions UI 手动触发此工作流
  workflow_dispatch:
    inputs:
      version:
        description: "要发布的版本 (例如: v0.1.0)"
        required: true
        type: string

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write # 需要写权限才能将提交、标签和 Release 推送回仓库
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}

      - name: 设置 Go 环境
        uses: actions/setup-go@v5
        with:
          go-version: "1.23" # 确保此版本与您的项目匹配

      - name: 配置 Git 用户
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: 验证版本格式
        run: |
          VERSION=${{ github.event.inputs.version }}
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::版本格式不正确，必须为 vX.Y.Z 格式。"
            exit 1
          fi

      - name: [1/6] 更新 version.go
        run: |
          set -e
          VERSION=${{ github.event.inputs.version }}
          echo "===== [1/6] 正在更新 version.go... ====="
          # 使用 sed 更新 version.go 中的版本号
          # 该文件路径相对于仓库根目录
          sed -i "s/^\s*VERSION = \".*\"/\tVERSION = \"$VERSION\"/" version.go
          echo "-> version.go 已更新为版本 $VERSION"
          echo "==================================="
          echo ""

      - name: [2/6] 更新子模块依赖
        run: |
          set -e
          VERSION=${{ github.event.inputs.version }}
          echo "===== [2/6] 正在更新子模块依赖... ====="
          find . -name go.mod | while read -r mod_file; do
            dir=$(dirname "$mod_file")
            if [ "$dir" == "." ]; then
              continue
            fi
            module_path=${dir#./}
            echo "-> 正在处理模块: $module_path"
            (
              cd "$dir"
              # 对于非 contrib 模块，移除本地 replace 指令以确保从远程拉取。
              # 对于 contrib 模块，则保留该指令。
              if [[ "$module_path" != contrib* ]]; then
                if grep -q "github.com/graingo/maltose =>" go.mod; then
                  echo "--> 非 contrib 模块，移除 replace 指令..."
                  go mod edit -dropreplace=github.com/graingo/maltose
                fi
              else
                echo "--> contrib 模块，跳过移除 replace 指令。"
              fi
              # 将依赖设置为新版本
              go mod edit -require="github.com/graingo/maltose@$VERSION"
              # 此处不执行 go mod tidy，因为此时 $VERSION 标签尚未在远程仓库中创建，
              # 执行 tidy 会导致依赖解析失败。
              # go.sum 文件将在使用者下次执行 go mod tidy 时自动更新。
            )
          done
          echo "=========================================="
          echo ""

      - name: [3/6] 提交变更
        run: |
          set -e
          VERSION=${{ github.event.inputs.version }}
          echo "===== [3/6] 正在提交变更... ====="
          # 检查是否有文件变更需要提交
          if [[ -z $(git status -s --untracked-files=no) ]]; then
            echo "-> 没有文件变更需要提交。"
          else
            echo "-> 正在提交所有 go.mod 和 go.sum 文件的变更..."
            git add .
            git commit -m "release: $VERSION"
          fi
          echo "================================"
          echo ""

      - name: [4/6] 创建并推送标签
        run: |
          set -e
          VERSION=${{ github.event.inputs.version }}
          echo "===== [4/6] 正在创建并推送标签... ====="
          echo "-> 正在为根模块打标签: $VERSION"
          git tag "$VERSION"

          # 查找所有子目录中的 go.mod 文件并为其打标签
          find . -name go.mod | while read -r mod_file; do
            dir=$(dirname "$mod_file")
            if [ "$dir" == "." ]; then
              continue
            fi
            module_path=${dir#./}
            TAG_NAME="${module_path}/${VERSION}"
            echo "-> 正在为子模块 '$module_path' 打标签: $TAG_NAME"
            git tag "$TAG_NAME"
          done
          echo "===================================="

          echo ""
          echo "正在将提交和所有标签推送到远程仓库..."
          git push origin HEAD
          git push origin --tags

          echo "✅ 推送完成！"

      - name: [5/6] 构建二进制文件
        id: build
        run: |
          set -e
          echo "===== [5/6] 正在构建二进制文件... ====="
          # 创建一个目录来存放构建产物
          ARTIFACT_DIR=release_artifacts
          mkdir -p $ARTIFACT_DIR
          
          # 构建目标平台
          TARGETS="linux/amd64 windows/amd64 darwin/amd64"
          
          for target in $TARGETS; do
            GOOS=$(echo $target | cut -d'/' -f1)
            GOARCH=$(echo $target | cut -d'/' -f2)
            OUTPUT_NAME="maltose-${GOOS}-${GOARCH}"
            if [ "$GOOS" = "windows" ]; then
              OUTPUT_NAME+=".exe"
            fi
            
            echo "-> 正在构建: $OUTPUT_NAME"
            CGO_ENABLED=0 GOOS=$GOOS GOARCH=$GOARCH go build -o "${ARTIFACT_DIR}/${OUTPUT_NAME}" ./cmd/maltose
          done
          
          echo "-> 构建产物列表:"
          ls -l $ARTIFACT_DIR
          
          # 将产物路径设置为输出，方便后续步骤使用
          echo "files=${ARTIFACT_DIR}/*" >> $GITHUB_OUTPUT
          echo "===================================="

      - name: [6/6] 创建 GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.build.outputs.files }}
          tag_name: ${{ github.event.inputs.version }}
          name: "${{ github.event.inputs.version }}"
          generate_release_notes: true
          draft: false
          prerelease: false
