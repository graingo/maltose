package openapi

import (
	"fmt"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// BuildSpec constructs the full OpenAPI v3 specification from the parsed API definitions.
func BuildSpec(apiDefs []APIDefinition, projectName string) (*openapi3.T, error) {
	spec := &openapi3.T{
		OpenAPI: "3.0.0",
		Info: &openapi3.Info{
			Title:       fmt.Sprintf("%s API", projectName),
			Version:     "1.0.0",
			Description: "API documentation generated by Maltose.",
		},
		Paths: openapi3.NewPaths(),
	}

	for _, apiDef := range apiDefs {
		if apiDef.Path == "" {
			continue
		}

		pathItem := spec.Paths.Find(apiDef.Path)
		if pathItem == nil {
			pathItem = &openapi3.PathItem{}
			spec.Paths.Set(apiDef.Path, pathItem)
		}

		op := &openapi3.Operation{
			Tags:        []string{apiDef.Tag},
			Summary:     apiDef.Summary,
			Description: apiDef.Description,
			Responses:   openapi3.NewResponses(),
		}

		// Handle Request
		if strings.ToUpper(apiDef.Method) == "GET" {
			for _, field := range apiDef.Request.Fields {
				op.Parameters = append(op.Parameters, &openapi3.ParameterRef{
					Value: openapi3.NewQueryParameter(field.JSONName).
						WithDescription(field.Description).
						WithRequired(field.Required).
						WithSchema(goTypeToSchema(field.Type)),
				})
			}
		} else { // POST, PUT, DELETE etc.
			reqSchema := openapi3.NewObjectSchema()
			for _, field := range apiDef.Request.Fields {
				reqSchema.Properties[field.JSONName] = openapi3.NewSchemaRef("", goTypeToSchema(field.Type))
				if field.Required {
					reqSchema.Required = append(reqSchema.Required, field.JSONName)
				}
			}
			op.RequestBody = &openapi3.RequestBodyRef{
				Value: openapi3.NewRequestBody().
					WithDescription(apiDef.Request.Name).
					WithContent(openapi3.NewContentWithJSONSchema(reqSchema)),
			}
		}

		// Handle Response
		resSchema := openapi3.NewObjectSchema()
		for _, field := range apiDef.Response.Fields {
			resSchema.Properties[field.JSONName] = openapi3.NewSchemaRef("", goTypeToSchema(field.Type))
		}
		op.Responses.Set("200", &openapi3.ResponseRef{
			Value: openapi3.NewResponse().
				WithDescription("Success").
				WithContent(openapi3.NewContentWithJSONSchema(resSchema)),
		})

		// Add operation to path item
		switch strings.ToUpper(apiDef.Method) {
		case "GET":
			pathItem.Get = op
		case "POST":
			pathItem.Post = op
		case "PUT":
			pathItem.Put = op
		case "DELETE":
			pathItem.Delete = op
		}
	}

	return spec, nil
}

// goTypeToSchema converts a basic Go type string to an OpenAPI schema.
func goTypeToSchema(goType string) *openapi3.Schema {
	switch goType {
	case "string":
		return openapi3.NewStringSchema()
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64":
		return openapi3.NewIntegerSchema()
	case "float32", "float64":
		return openapi3.NewFloat64Schema()
	case "bool":
		return openapi3.NewBoolSchema()
	default:
		// For complex types, you might want to reference a schema in #/components/schemas
		// For now, treat as a string.
		schema := openapi3.NewStringSchema()
		schema.Description = "Complex type: " + goType
		return schema
	}
}
