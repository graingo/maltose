package openapi

import (
	"fmt"
	"go/ast"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// schemaBuilder holds the state for building the OpenAPI specification,
// including component schemas and a map of all parsed struct ASTs.
type schemaBuilder struct {
	spec       *openapi3.T
	allStructs map[string]*ast.StructType
}

// BuildSpec constructs the full OpenAPI v3 specification from the parsed API definitions.
func BuildSpec(apiDefs []APIDefinition, projectName string, allStructs map[string]*ast.StructType) (*openapi3.T, error) {
	spec := &openapi3.T{
		OpenAPI: "3.0.0",
		Info: &openapi3.Info{
			Title:       fmt.Sprintf("%s API", projectName),
			Version:     "1.0.0",
			Description: "API documentation generated by Maltose.",
		},
		Paths:      openapi3.NewPaths(),
		Components: &openapi3.Components{},
	}
	spec.Components.Schemas = make(openapi3.Schemas)

	builder := &schemaBuilder{
		spec:       spec,
		allStructs: allStructs,
	}

	for _, apiDef := range apiDefs {
		if apiDef.Path == "" {
			continue
		}

		pathItem := spec.Paths.Find(apiDef.Path)
		if pathItem == nil {
			pathItem = &openapi3.PathItem{}
			spec.Paths.Set(apiDef.Path, pathItem)
		}

		op := &openapi3.Operation{
			Tags:        []string{apiDef.Tag},
			Summary:     apiDef.Summary,
			Description: apiDef.Description,
			Responses:   openapi3.NewResponses(),
		}

		// Handle Request
		if strings.ToUpper(apiDef.Method) == "GET" {
			for _, field := range apiDef.Request.Fields {
				paramSchema := builder.typeToSchemaRef(field.Type).Value // Unpack SchemaRef for parameters
				param := openapi3.NewQueryParameter(field.JSONName).
					WithDescription(field.Description).
					WithRequired(field.Required).
					WithSchema(paramSchema)
				op.Parameters = append(op.Parameters, &openapi3.ParameterRef{
					Value: param,
				})
			}
		} else { // POST, PUT, DELETE etc.
			reqSchema := openapi3.NewObjectSchema()
			for _, field := range apiDef.Request.Fields {
				fieldSchemaRef := builder.typeToSchemaRef(field.Type)
				if field.Description != "" && fieldSchemaRef.Value != nil {
					fieldSchemaRef.Value.Description = field.Description
				}
				reqSchema.Properties[field.JSONName] = fieldSchemaRef
				if field.Required {
					reqSchema.Required = append(reqSchema.Required, field.JSONName)
				}
			}
			op.RequestBody = &openapi3.RequestBodyRef{
				Value: openapi3.NewRequestBody().
					WithDescription(apiDef.Request.Name).
					WithContent(openapi3.NewContentWithJSONSchemaRef(&openapi3.SchemaRef{Value: reqSchema})),
			}
		}

		// Handle Response
		resSchema := openapi3.NewObjectSchema()
		for _, field := range apiDef.Response.Fields {
			fieldSchemaRef := builder.typeToSchemaRef(field.Type)
			if field.Description != "" && fieldSchemaRef.Value != nil {
				fieldSchemaRef.Value.Description = field.Description
			}
			resSchema.Properties[field.JSONName] = fieldSchemaRef
		}
		op.Responses.Set("200", &openapi3.ResponseRef{
			Value: openapi3.NewResponse().
				WithDescription("Success").
				WithContent(openapi3.NewContentWithJSONSchemaRef(&openapi3.SchemaRef{Value: resSchema})),
		})

		// Add operation to path item
		switch strings.ToUpper(apiDef.Method) {
		case "GET":
			pathItem.Get = op
		case "POST":
			pathItem.Post = op
		case "PUT":
			pathItem.Put = op
		case "DELETE":
			pathItem.Delete = op
		}
	}

	return spec, nil
}

// typeToSchemaRef converts a Go type string into an OpenAPI SchemaRef.
// It handles primitives, pointers, slices, and generates component schemas for custom structs.
func (b *schemaBuilder) typeToSchemaRef(goType string) *openapi3.SchemaRef {
	// Handle pointers
	if strings.HasPrefix(goType, "*") {
		ref := b.typeToSchemaRef(strings.TrimPrefix(goType, "*"))
		// If it's a ref to a component, the component itself is not nullable. The ref is.
		// If it's an inline schema, we can set nullable.
		if ref.Value != nil {
			ref.Value.Nullable = true
		}
		return ref
	}

	// Handle slices/arrays
	if strings.HasPrefix(goType, "[]") {
		innerType := strings.TrimPrefix(goType, "[]")
		itemsRef := b.typeToSchemaRef(innerType)
		schema := openapi3.NewArraySchema()
		schema.Items = itemsRef
		return &openapi3.SchemaRef{Value: schema}
	}

	// Handle primitive types
	switch goType {
	case "string":
		return &openapi3.SchemaRef{Value: openapi3.NewStringSchema()}
	case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64":
		return &openapi3.SchemaRef{Value: openapi3.NewIntegerSchema()}
	case "float32", "float64":
		return &openapi3.SchemaRef{Value: openapi3.NewFloat64Schema()}
	case "bool":
		return &openapi3.SchemaRef{Value: openapi3.NewBoolSchema()}
	case "interface{}":
		return &openapi3.SchemaRef{Value: &openapi3.Schema{Type: &openapi3.Types{openapi3.TypeObject}, AdditionalProperties: openapi3.AdditionalProperties{Has: openapi3.BoolPtr(true)}}}
	}

	// Handle custom struct types by creating a component schema
	cleanTypeName := goType
	if i := strings.LastIndex(goType, "."); i != -1 {
		cleanTypeName = goType[i+1:]
	}

	// If the schema is not already in components, create it.
	if _, ok := b.spec.Components.Schemas[cleanTypeName]; !ok {
		structAST, found := b.allStructs[cleanTypeName]
		if !found {
			// Struct definition not found, return a generic object schema as a fallback.
			schema := openapi3.NewObjectSchema()
			schema.Description = "Unresolved custom type: " + goType
			return &openapi3.SchemaRef{Value: schema}
		}

		// Add a placeholder to components to prevent infinite recursion for self-referencing structs.
		b.spec.Components.Schemas[cleanTypeName] = &openapi3.SchemaRef{Value: openapi3.NewObjectSchema()}

		// Build the full schema for the struct.
		schema := openapi3.NewObjectSchema()
		structInfo := parseStructInfo(cleanTypeName, structAST, "POST") // Use "POST" to favor `json` tags.
		for _, field := range structInfo.Fields {
			fieldSchemaRef := b.typeToSchemaRef(field.Type)
			if field.Description != "" && fieldSchemaRef.Value != nil {
				fieldSchemaRef.Value.Description = field.Description
			}
			schema.Properties[field.JSONName] = fieldSchemaRef
			if field.Required {
				schema.Required = append(schema.Required, field.JSONName)
			}
		}

		// Replace the placeholder with the fully constructed schema.
		b.spec.Components.Schemas[cleanTypeName] = &openapi3.SchemaRef{Value: schema}
	}

	// Return a reference to the component schema.
	return openapi3.NewSchemaRef(fmt.Sprintf("#/components/schemas/%s", cleanTypeName), nil)
}
